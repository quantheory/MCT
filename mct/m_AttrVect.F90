!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !MODULE: m_AttrVect - a distributed Innovation vector
!
! !DESCRIPTION:
!
! An {\em attribute vector} is a scheme for storing bundles of integer 
! and real data vectors, indexed by lists of their respective attributes.
! The attribute vector is implemented in Fortran 90 using the 
! {\tt AttrVect} derived type.  This module contains the definition of
! {\tt AttrVect} class, and numerous methods that service it.
!
! !INTERFACE:

 module m_AttrVect
!
! !USES:
!
      use m_List, only : List   ! Support for rList and iList components.

      implicit none

      private	! except

! !PUBLIC TYPES:

      public :: AttrVect        ! The class data structure

    type AttrVect
      type(List) :: iList
      type(List) :: rList
      integer,dimension(:,:),pointer :: iAttr
      real   ,dimension(:,:),pointer :: rAttr
    end type AttrVect

! !PUBLIC MEMBER FUNCTIONS:

      public :: init		! create a local vector
      public :: clean		! clean the local vector
      public :: zero		! zero the local vector
      public :: lsize		! size of the local vector
      public :: nIAttr		! number of integer attributes on local
      public :: nRAttr		! number of real attributes on local
      public :: indexIA		! index the integer attributes
      public :: indexRA		! index the real attributes
      public :: getIList        ! return list of integer attributes
      public :: getRList        ! return list of real attributes
      public :: exportIList     ! export INTEGER attibute List
      public :: exportRList     ! export REAL attibute List
      public :: exportIListToChar ! export INTEGER attibute List as Char
      public :: exportRListToChar ! export REAL attibute List as Char
      public :: exportIAttr     ! export INTEGER attribute to vector
      public :: exportRAttr     ! export REAL attribute to vector
      public :: importIAttr     ! import INTEGER attribute from vector
      public :: importRAttr     ! import REAL attribute from vector
      public :: Copy		! copy attributes from one Av to another
      public :: Sort            ! sort entries, and return permutation
      public :: Permute         ! permute entries
      public :: SortPermute     ! sort and permute entries
      public :: SharedAttrIndexList  ! Returns the number of shared
				     ! attributes, and lists of the
				     ! respective locations of these
				     ! shared attributes

    interface init   ; module procedure	&
	init_,	&
	initv_, &
	initl_
    end interface
    interface clean  ; module procedure clean_  ; end interface
    interface zero  ; module procedure zero_  ; end interface
    interface lsize  ; module procedure lsize_  ; end interface
    interface nIAttr ; module procedure nIAttr_ ; end interface
    interface nRAttr ; module procedure nRAttr_ ; end interface
    interface indexIA; module procedure indexIA_; end interface
    interface indexRA; module procedure indexRA_; end interface
    interface getIList; module procedure getIList_; end interface
    interface getRList; module procedure getRList_; end interface
    interface exportIList; module procedure exportIList_; end interface
    interface exportRList; module procedure exportRList_; end interface
    interface exportIListToChar
       module procedure exportIListToChar_
    end interface
    interface exportRListToChar
       module procedure exportRListToChar_
    end interface
    interface exportIAttr; module procedure exportIAttr_; end interface
    interface exportRAttr; module procedure exportRAttr_; end interface
    interface importIAttr; module procedure importIAttr_; end interface
    interface importRAttr; module procedure importRAttr_; end interface
    interface Copy    ; module procedure Copy_    ; end interface
    interface Sort    ; module procedure Sort_    ; end interface
    interface Permute ; module procedure Permute_ ; end interface
    interface SortPermute ; module procedure SortPermute_ ; end interface
    interface SharedAttrIndexList ; module procedure aVaVSharedAttrIndexList_ ; end interface

! !REVISION HISTORY:
! 	10Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	10Oct00 - J.W. Larson <larson@mcs.anl.gov> - made getIList
!                 and getRList functions public and added appropriate
!                 interface definitions
!       20Oct00 - J.W. Larson <larson@mcs.anl.gov> - added Sort, 
!                 Permute, and SortPermute functions.
!       09May01 - J.W. Larson <larson@mcs.anl.gov> - added initl_().
!       19Oct01 - J.W. Larson <larson@mcs.anl.gov> - added routines 
!                 exportIattr(), exportRAttr(), importIAttr(), 
!                 and importRAttr().  Also cleaned up module and 
!                 routine prologues.
!       13Dec01 - J.W. Larson <larson@mcs.anl.gov> - made importIAttr()
!                 and importRAttr() public (bug fix).
!       14Dec01 - J.W. Larson <larson@mcs.anl.gov> - added exportIList()
!                 and exportRList().
!       14Feb02 - J.W. Larson <larson@mcs.anl.gov> - added CHARCTER
!                 functions exportIListToChar() and exportRListToChar()
!       26Feb02 - J.W. Larson <larson@mcs.anl.gov> - corrected of usage
!                 of m_die routines throughout this module.
!       16Apr02 - J.W. Larson <larson@mcs.anl.gov> - added the method
!                 LocalReduce(), and the public data members AttrVectSUM,
!                 AttrVectMIN, and AttrVectMAX.
!        7May02 - J.W. Larson <larson@mcs.anl.gov> - Refactoring.  Moved
!                 LocalReduce() and the public data members AttrVectSUM,
!                 AttrVectMIN, and AttrVectMAX to a new module named
!                 m_AttrVectReduce.
!       12Jun02 - R.L. Jacob <jacob@mcs.anl.gov> - add Copy function
!       13Jun02 - R.L. Jacob <jacob@mcs.anl.gov> - move aVavSharedAttrIndexList
!                 to this module from old m_SharedAttrIndicies
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname='m_AttrVect'

 contains

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: init_ - initialize with given iList, rList, and the size
!
! !DESCRIPTION:
!
! !INTERFACE:

 subroutine init_(aV,iList,rList,lsize)
!
! !USES:
!
      use m_List, only : List
      use m_List, only : init,nitem
      use m_List, only : List_nullify => nullify
      use m_mall
      use m_die
      implicit none

      type(AttrVect),intent(out) :: aV
      character(len=*),optional,intent(in) :: iList
      character(len=*),optional,intent(in) :: rList
      integer,         optional,intent(in) :: lsize

! !REVISION HISTORY:
! 	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	09Oct01 - J.W. Larson <larson@mcs.anl.gov> - added feature to
!                 nullify all pointers before usage.  This was done to
!                 accomodate behavior of the f90 ASSOCIATED intrinsic 
!                 function on the AIX platform.
!       07Dec01 - E.T. Ong <eong@mcs.anl.gov> - added support for 
!                 intialization with blank character strings for iList
!                 and rList
!EOP ___________________________________________________________________
!
  character(len=*),parameter :: myname_=myname//'::init_'
  integer :: nIA,nRA,n,ier

       ! Initially, nullify all pointers in the AttrVect aV:

  nullify(aV%iAttr)
  nullify(aV%rAttr)
  call List_nullify(aV%iList)
  call List_nullify(aV%rList)

  if( present(rList) .and. (len_trim(rList)>0) ) then
    call init(aV%rList,rList)	! init.List()
  endif

  if( present(iList) .and. (len_trim(iList)>0) ) then
    call init(aV%iList,iList)	! init.List()
  endif

  nIA=nitem(aV%iList)		! nitem.List()
  nRA=nitem(aV%rList)		! nitem.List()

  n=0
  if(present(lsize)) n=lsize

  allocate( aV%iAttr(nIA,n),aV%rAttr(nRA,n),	stat=ier)
  if(ier /= 0) call die(myname_,'allocate()',ier)

#ifdef MALL_ON
	call mall_ci(size(transfer(aV%iAttr,(/1/)),myname_)
	call mall_ci(size(transfer(aV%rAttr,(/1/)),myname_)
#endif

 end subroutine init_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: initv_ - initialize one AttrVect from another.
!
! !DESCRIPTION:  This routine takes an input {\tt AttrVect} argument 
! {\tt bV}, and uses its attribute list information to create an output
! {\tt AttrVect} variable {\tt aV}.  The length of {\tt aV} is defined 
! by the input {\tt INTEGER} argument {\tt lsize}.
!
! !INTERFACE:

 subroutine initv_(aV,bV,lsize)
!
! !USES:
!
      use m_String, only : String,char
      use m_List,   only : get
      use m_List,   only : List_nullify => nullify
      use m_die
      use m_stdio

      implicit none

! !INPUT PARAMETERS: 
!
      type(AttrVect),intent(in)  :: bV
      integer,       intent(in)  :: lsize

! !OUTPUT PARAMETERS: 
!
      type(AttrVect),intent(out) :: aV

! !REVISION HISTORY:
! 	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
!       17May01 - R. Jacob <jacob@mcs.anl.gov> - add a check to see if
!                 input argument has been defined.  SGI will dump
!                 core if its not.
!       10Oct01 - J. Larson <larson@mcs.anl.gov> - Nullify all pointers
!                 in ouput AttrVect aV before initializing aV.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::initv_'
  type(String) :: iLStr,rLStr

	! Step One:  Nullify all pointers in aV.  We will set
        ! only the pointers we really need for aV based on those
        ! currently ASSOCIATED in bV.

  call List_nullify(aV%iList)
  call List_nullify(aV%rList)
  nullify(aV%iAttr)
  nullify(aV%rAttr)

	! Convert the two Lists to two Strings

  if(.not.associated(bv%iList%bf) .and. & 
       .not.associated(bv%rList%bf)) then
     write(stderr,'(2a)')myname_, &
      'MCTERROR:  Trying to initialize a new AttrVect off an undefined AttrVect'
      call die(myname_,'undefined input argument',0)
  endif

  if(associated(bv%iList%bf)) then
     call get(iLStr,bv%iList)
  endif

  if(associated(bv%rList%bf)) then
     call get(rLStr,bv%rList)
  endif

       ! Initialize the AttrVect aV depending on which parts of
       ! the input bV are valid:

  if(associated(bv%iList%bf) .and. associated(bv%rList%bf)) then
     call init_(aV,iList=char(iLStr),rList=char(rLStr),lsize=lsize)
  endif
  if(.not.associated(bv%iList%bf) .and. associated(bv%rList%bf)) then
     call init_(aV,rList=char(rLStr),lsize=lsize)
  endif
  if(associated(bv%iList%bf) .and. .not.associated(bv%rList%bf)) then
     call init_(aV,iList=char(iLStr),lsize=lsize)
  endif

 end subroutine initv_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: initl_ - initialize with Lists iList, rList, and the size
!
! !DESCRIPTION:  This routine initializes an {\tt AttrVect} directly 
! from input {\tt List} data type arguments {\tt iList} and {\tt rList} 
! (see the module {\tt m\_List} in mpeu for further details), and an
! input length {\tt lsize}.  The resulting {\tt AttrVect} is returned in
! the argument {\tt aV}.
!
! {\bf N.B.}:  The outcome of this routine, {\tt aV} represents 
! allocated memory.  When this {\tt AttrVect} is no longer needed, 
! it must be deallocated by invoking the routine {\tt AttrVect\_clean()}.  
! Failure to do so will spawn a memory leak.
!
! !INTERFACE:

 subroutine initl_(aV, iList, rList, lsize)

!
! !USES:
!
      use m_die
      use m_stdio
      use m_mall

      use m_String, only : String
      use m_String, only : String_clean => clean
      use m_String, only : String_toChar => toChar

      use m_List, only : List
      use m_List, only : List_init => init
      use m_List, only : List_nitem => nitem
      use m_List, only : List_copy => copy
      use m_List, only : List_get => get
      use m_List,   only : List_nullify => nullify

      implicit none

! !INPUT PARAMETERS: 
!
      type(List),  intent(in)  :: iList
      type(List),  intent(in)  :: rList
      integer,     intent(in)  :: lsize

! !OUTPUT PARAMETERS:
!
      type(AttrVect), intent(out) :: aV

! !REVISION HISTORY:
! 	09May98 - J.W. Larson <larson@mcs.anl.gov> - initial version.
!       08Aug01 - E.T. Ong <eong@mcs.anl.gov> - change list assignment(=)
!                 to list copy to avoid compiler errors with pgf90.
!       10Oct01 - J. Larson <larson@mcs.anl.gov> - Nullify all pointers
!                 in ouput AttrVect aV before initializing aV.  Also, 
!                 greater caution taken regarding validity of input 
!                 arguments iList and rList.
!EOP ___________________________________________________________________
!
  character(len=*),parameter :: myname_=myname//'::initl_'
  integer :: nIA, nRA, ier

	! Step One:  Nullify all pointers in aV.  We will set
        ! only the pointers we really need for aV based on those
        ! currently ASSOCIATED in bV.

  call List_nullify(aV%iList)
  call List_nullify(aV%rList)
  nullify(aV%iAttr)
  nullify(aV%rAttr)

       ! Assign iList to aV%iList and rList to aV%rList

  if(associated(iList%bf)) then
     call List_copy(aV%iList,iList)
  endif

  if(associated(rList%bf)) then
     call List_copy(aV%rList,rList)
  endif

       ! Count items in aV%iList and aV%rList: 

  if(associated(aV%iList%bf)) then
     nIA = List_nitem(aV%iList)
  else
     nIA = 0
  endif

  if(associated(aV%rList%bf)) then
     nRA = List_nitem(aV%rList)
  else
     nRA = 0
  endif

  if(lsize < 0) then 
     write(stderr,*) myname_,":: Warning:  length argument lsize negative."
  endif

  if(lsize >= 0) then

     if(associated(aV%iList%bf) .and. associated(aV%rList%bf)) then
	allocate( aV%iAttr(nIA,lsize), aV%rAttr(nRA,lsize), stat=ier)
	if(ier /= 0) call die(myname_,'allocate(aV%iAttr,aV%rAttr)',ier)
#ifdef MALL_ON
	call mall_ci(size(transfer(aV%iAttr,(/1/)),myname_)
	call mall_ci(size(transfer(aV%rAttr,(/1/)),myname_)
#endif
     endif

     if(associated(aV%iList%bf) .and. .not.associated(aV%rList%bf)) then
	allocate( aV%iAttr(nIA,lsize), stat=ier)
	if(ier /= 0) call die(myname_,'allocate(aV%iAttr)',ier)
#ifdef MALL_ON
	call mall_ci(size(transfer(aV%iAttr,(/1/)),myname_)
#endif
     endif

     if(.not.associated(aV%iList%bf) .and. associated(aV%rList%bf)) then
	allocate( aV%rAttr(nRA,lsize), stat=ier)
	if(ier /= 0) call die(myname_,'allocate(aV%rAttr)',ier)
#ifdef MALL_ON
	call mall_ci(size(transfer(aV%rAttr,(/1/)),myname_)
#endif
     endif

  endif ! if(lsize > 0)... block

 end subroutine initl_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: clean_ - clean a vector
!
! !DESCRIPTION:
!
! !INTERFACE:

 subroutine clean_(aV,stat)
!
! !USES:
!
      use m_mall
      use m_stdio
      use m_die
      use m_List, only : List_clean => clean

      implicit none

      type(AttrVect),    intent(inout) :: aV
      integer, optional, intent(out)   :: stat

! !REVISION HISTORY:
! 	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	10Oct01 - J. Larson <larson@mcs.anl.gov> - various fixes to 
!                 prevent deallocation of UNASSOCIATED pointers.
!       01Mar01 - E.T. Ong <eong@mcs.anl.gov> - removed dies to prevent
!                 crashes when cleaning uninitialized attrvects. Added
!                 optional stat argument.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::clean_'
  integer :: ier

	! Note that an undefined pointer may either crash the process
	! or return either .true. or .false. to the associated() test.
	! One should therefore avoid using the function on an 
	! undefined pointer.

        ! Clean up INTEGER attribute list:

  if(present(stat)) stat=0
  
  if(associated(aV%iList%bf)) then

     if(present(stat)) then
	call List_clean(aV%iList,ier)
	if(ier/=0) stat=ier
     else
	call List_clean(aV%iList)
     endif

  endif

        ! Clean up REAL attribute list:

  if(associated(aV%rList%bf)) then

     if(present(stat)) then
	call List_clean(aV%rList,ier)
	if(ier/=0) stat=ier
     else
	call List_clean(aV%rList)
     endif

  endif

        ! Clean up INTEGER attributes:

  if(associated(aV%iAttr)) then

#ifdef MALL_ON
     call mall_co(size(transfer(aV%iAttr,(/1/)),myname_)
#endif

     deallocate(aV%iAttr,stat=ier)

     if(ier /= 0) then
	if(present(stat)) then
	   stat=ier
	else
	   call warn(myname_,'deallocate(aV%iAttr)',ier)
	endif
     endif

  endif ! if(associated(aV%iAttr))...
  
        ! Clean up REAL attributes:

  if(associated(aV%rAttr)) then

#ifdef MALL_ON
     call mall_co(size(transfer(aV%rAttr,(/1/)),myname_)
#endif

     deallocate(aV%rAttr,stat=ier)

     if(ier /= 0) then
	if(present(stat)) then
	   stat=ier
	else
	   call warn(myname_,'deallocate(aV%rAttr)',ier)
	endif
     endif

  endif ! if(associated(aV%rAttr))...


 end subroutine clean_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: lsize_ - the local size of the vector
!
! !DESCRIPTION:
!
! !INTERFACE:

 integer function lsize_(aV)

! !USES:

     use m_stdio, only : stderr
     use m_die
 
     implicit none

      type(AttrVect), intent(in) :: aV

! !REVISION HISTORY:
! 	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	10Oct01 - J. Larson <larson@mcs.anl.gov> - made code more robust
!                 to handle cases where the length of either aV%iAttr or
!                 aV%rAttr is zero, but the other is positive.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::lsize_'
  integer :: iLength, rLength

	! One should try to avoid using this function on an undefined
	! or disassocated pointer.  However, it is understandable 
	! that an undefined or disassocated pointer has a size 0, if
	! the associated() test sucesses.

  lsize_=0

  if(associated(aV%iAttr)) then
     iLength = size(aV%iAttr,2)
  else
     iLength = 0
  endif

  if(associated(aV%rAttr)) then
     rLength = size(aV%rAttr,2)
  else
     rLength = 0
  endif

  if(iLength /= rLength) then

     if((rLength > 0) .and. (iLength > 0)) then
	call die(myname_,'attribute array length mismatch', &
	     iLength-rLength)
     endif

     if((rLength > 0) .and. (iLength == 0)) then
	lsize_ = rLength
     endif

     if((iLength > 0) .and. (rLength == 0)) then
	lsize_ = iLength
     endif

  endif

  if(iLength == rLength) lsize_ = iLength

 end function lsize_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!        Math and Computer Science Division, Argonne National Laboratory
!BOP -------------------------------------------------------------------
!
! !IROUTINE: zero_ - zero the local vector
!
! !DESCRIPTION:
!
! !INTERFACE:

 subroutine zero_(aV)

! !USES:

     use m_die,only	: die
     use m_stdio,only	: stderr
 
     implicit none

     type(AttrVect), intent(inout) :: aV

! !REVISION HISTORY:
! 	17May01 - R. Jacob <jacob@mcs.anl.gov> - initial prototype/code
! 	15Oct01 - J. Larson <larson@mcs.anl.gov> - switched loop order
!                 for cache optimization.
!       03Dec01 - E.T. Ong <eong@mcs.anl.gov> - eliminated looping method of
!                 of zeroing. "Compiler assignment" of attrvect performs faster
!                 on the IBM SP with mpxlf90 compiler.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::zero_'

  if(.not.associated(aV%iAttr) .and. .not.associated(aV%rAttr)) then
    write(stderr,'(2a)')myname_, &
      'MCTERROR:  Trying to zero an uninitialized AttrVect'
      call die(myname_,'undefined input argument',0)
  endif

  if(nIAttr_(aV)>0) aV%iAttr=0
  if(nRAttr_(aV)>0) aV%rAttr=0.


 end subroutine zero_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: nIAttr_ - number of INTEGER type attributes
!
! !DESCRIPTION:
!
! !INTERFACE:

 function nIAttr_(aV)
!
! !USES:
!
      use m_List, only : nitem

      implicit none
      type(AttrVect),intent(in) :: aV
      integer :: nIAttr_

! !REVISION HISTORY:
! 	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	10Oct01 - J. Larson <larson@mcs.anl.gov> - made code more robust
!                 by checking status of pointers in aV%iList
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::nIAttr_'

  if(associated(aV%iList%bf)) then
     nIAttr_ = nitem(aV%iList)
  else
     nIAttr_ = 0
  endif

 end function nIAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: nRAttr_ - number of REAL type attributes
!
! !DESCRIPTION:
!
! !INTERFACE:

 function nRAttr_(aV)
!
! !USES:
!
      use m_List, only : nitem

      implicit none

      type(AttrVect),intent(in) :: aV
      integer :: nRAttr_

! !REVISION HISTORY:
! 	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
! 	10Oct01 - J. Larson <larson@mcs.anl.gov> - made code more robust
!                 by checking status of pointers in aV%iList
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::nRAttr_'

  if(associated(aV%rList%bf)) then
     nRAttr_ = nitem(aV%rList)
  else
     nRAttr_ = 0
  endif

 end function nRAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: getIList_ - get an item from iList
!
! !DESCRIPTION:
!
! !INTERFACE:

 subroutine getIList_(item,ith,aVect)
!
! !USES:
!
      use m_String, only : String
      use m_List,   only : get

      implicit none

      type(String),intent(out) :: item
      integer,     intent(in)  :: ith
      type(AttrVect),intent(in) :: aVect

! !REVISION HISTORY:
! 	24Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::getIList_'

  call get(item,ith,aVect%iList)

 end subroutine getIList_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: getRList_ - get an item from rList
!
! !DESCRIPTION:
!
! !INTERFACE:

 subroutine getRList_(item,ith,aVect)
!
! !USES:
!
      use m_String, only : String
      use m_List,   only : get

      implicit none

      type(String),intent(out) :: item
      integer,     intent(in)  :: ith
      type(AttrVect),intent(in) :: aVect

! !REVISION HISTORY:
! 	24Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::getRList_'

  call get(item,ith,aVect%rList)

 end subroutine getRList_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: indexIA_ - index the integer attribute List
!
! !DESCRIPTION:
!
! !INTERFACE:

 function indexIA_(aV,item,perrWith,dieWith)
!
! !USES:
!
      use m_List, only : index
      use m_die,  only : die
      use m_stdio,only : stderr

      implicit none

      type(AttrVect), intent(in) :: aV
      character(len=*),intent(in) :: item
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith
      integer :: indexIA_

! !REVISION HISTORY:
! 	27Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::indexIA_'

  indexIA_=index(aV%iList,item)

	if(indexIA_==0) then
	  if(.not.present(dieWith)) then
	    if(present(perrWith)) write(stderr,'(4a)') perrWith, &
		'" indexIA_() error, not found "',trim(item),'"'
	  else
	    write(stderr,'(4a)') dieWith,	&
		'" indexIA_() error, not found "',trim(item),'"'
	    call die(dieWith)
	  endif
	endif

 end function indexIA_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       NASA/GSFC, Data Assimilation Office, Code 910.3, GEOS/DAS      !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: indexRA_ - index the integer attribute List
!
! !DESCRIPTION:
! 
!
! !INTERFACE:

 function indexRA_(aV,item,perrWith,dieWith)
!
! !USES:
!
      use m_List, only : index
      use m_die,  only : die
      use m_stdio,only : stderr

      implicit none

      type(AttrVect), intent(in) :: aV
      character(len=*),intent(in) :: item
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith
      integer :: indexRA_

! !REVISION HISTORY:
! 	27Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::indexRA_'

  indexRA_=index(aV%rList,item)

	if(indexRA_==0) then
	  if(.not.present(dieWith)) then
	    if(present(perrWith)) write(stderr,'(4a)') perrWith, &
		'" indexRA_() error, not found "',trim(item),'"'
	  else
	    write(stderr,'(4a)') dieWith,	&
		'" indexRA_() error, not found "',trim(item),'"'
	    call die(dieWith)
	  endif
	endif

 end function indexRA_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportIList_ - return AttrVect INTEGER attribute List
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the integer attribute list, and returns it as the {\tt List} output 
! argument {\tt outIList}.  The success (failure) of this operation is
! signified by a zero (nonzero) value for the optional {\tt INTEGER} 
! output argument {\tt status}.
!
! {\bf N.B.:}  This routine returns an allocated {\tt List} data 
! structure ({\tt outIList}).  The user is responsible for deallocating 
! this structure by invoking {\tt List\_clean()} (see the module 
! {\tt m\_List} for details) once it is no longer needed.  Failure to 
! do so will result in a memory leak.
!
! !INTERFACE:

 subroutine exportIList_(aV, outIList, status)

!
! !USES:
!
      use m_die ,  only : die
      use m_stdio, only : stderr

      use m_List,  only : List
      use m_List,  only : List_allocated => allocated
      use m_List,  only : List_copy => copy
      use m_List,  only : List_nullify => nullify

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),           intent(in)  :: aV

! !OUTPUT PARAMETERS: 

      type(List),               intent(out) :: outIList
      integer,        optional, intent(out) :: status

! !REVISION HISTORY:
! 	14Dec01 - J.W. Larson <larson@mcs.anl.gov> - initial prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportIList_'

       ! Initialize status flag (if present) to success value of zero.

  if(present(status)) status = 0

  if(List_allocated(aV%iList)) then
     call List_copy(outIList, aV%iList)
  else
     call List_nullify(outIList)
     if(present(status)) then
	status = 1
     else
	call die(myname_)
     endif
  endif

 end subroutine exportIList_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportRList_ - return AttrVect REAL attribute List
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the real attribute list, and returns it as the {\tt List} output 
! argument {\tt outRList}.  The success (failure) of this operation is
! signified by a zero (nonzero) value for the optional {\tt INTEGER} 
! output argument {\tt status}.
!
! {\bf N.B.:}  This routine returns an allocated {\tt List} data 
! structure ({\tt outRList}).  The user is responsible for deallocating 
! this structure by invoking {\tt List\_clean()} (see the module 
! {\tt m\_List} for details) once it is no longer needed.  Failure to 
! do so will result in a memory leak.
!
! !INTERFACE:

 subroutine exportRList_(aV, outRList, status)

!
! !USES:
!
      use m_die ,  only : die
      use m_stdio, only : stderr

      use m_List,  only : List
      use m_List,  only : List_allocated => allocated
      use m_List,  only : List_copy => copy
      use m_List,  only : List_nullify => nullify

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),           intent(in)  :: aV

! !OUTPUT PARAMETERS: 

      type(List),               intent(out) :: outRList
      integer,        optional, intent(out) :: status

! !REVISION HISTORY:
! 	14Dec01 - J.W. Larson <larson@mcs.anl.gov> - initial prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportRList_'

       ! Initialize status flag (if present) to success value of zero.

  if(present(status)) status = 0

  if(List_allocated(aV%rList)) then
     call List_copy(outRList, aV%rList)
  else
     call List_nullify(outRList)
     if(present(status)) then
	status = 1
     else
	call die(myname_)
     endif
  endif

 end subroutine exportRList_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportIListToChar_ - return AttrVecti\%iList as CHARACTER
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the integer attribute list, and returns it as a {\tt CHARACTER} 
! suitable for printing.
!
! !INTERFACE:

 function exportIListToChar_(aV)

!
! !USES:
!
      use m_die ,  only : die
      use m_stdio, only : stderr

      use m_List,  only : List
      use m_List,  only : List_allocated => allocated
      use m_List,  only : List_exportToChar => exportToChar

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),       intent(in) :: aV

! !OUTPUT PARAMETERS: 

      character(len=size(aV%iList%bf)) :: exportIListToChar_

! !REVISION HISTORY:
! 	13Feb02 - J.W. Larson <larson@mcs.anl.gov> - initial prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportIListToChar_'

  ! The following declaration avoids a bug in the SGI MIPSpro Fortran 90
  ! compiler version 7.30. If this line is removed, the following error 
  ! will occur during compile time:

  ! Signal: Segmentation fault in IR->WHIRL Conversion phase.
  ! "m_AttrVect.F90": Error: Signal Segmentation fault in phase IR->WHIRL 
  ! Conversion -- processing aborted
  ! f90 ERROR:  /opt/MIPSpro/73/usr/lib32/cmplrs/mfef90 died due to signal 4
  ! f90 ERROR:  core dumped
  ! *** Error code 32 (bu21)

  !::::::::::::::::::::::::::::::::!
  type(List) :: DoNotRemoveThisLine!
  !::::::::::::::::::::::::::::::::!

       ! Extract the INTEGER attribute list to a character:

  if(List_allocated(aV%iList)) then
     exportIListToChar_ = List_exportToChar(aV%iList)
  else
     call die(myname_)
  endif

 end function exportIListToChar_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportRListToChar_ - Return AttrVect\%rList as CHARACTER
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the real attribute list, and returns it as a {\tt CHARACTER} suitable 
! for printing.
!
! !INTERFACE:

 function exportRListToChar_(aV)

!
! !USES:
!
      use m_die ,  only : die
      use m_stdio, only : stderr

      use m_List,  only : List
      use m_List,  only : List_allocated => allocated
      use m_List,  only : List_exportToChar => exportToChar

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),       intent(in) :: aV

! !OUTPUT PARAMETERS: 

      character(len=size(aV%rList%bf)) :: exportRListToChar_

! !REVISION HISTORY:
! 	13Feb02 - J.W. Larson <larson@mcs.anl.gov> - initial prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportRListToChar_'

  ! The following declaration avoids a bug in the SGI MIPSpro Fortran 90
  ! compiler version 7.30. If this line is removed, the following error 
  ! will occur during compile time:

  ! Signal: Segmentation fault in IR->WHIRL Conversion phase.
  ! "m_AttrVect.F90": Error: Signal Segmentation fault in phase IR->WHIRL 
  ! Conversion -- processing aborted
  ! f90 ERROR:  /opt/MIPSpro/73/usr/lib32/cmplrs/mfef90 died due to signal 4
  ! f90 ERROR:  core dumped
  ! *** Error code 32 (bu21)

  !::::::::::::::::::::::::::::::::!
  type(List) :: DoNotRemoveThisLine!
  !::::::::::::::::::::::::::::::::!

       ! Extract the REAL attribute list to a character:

  if(List_allocated(aV%rList)) then
     exportRListToChar_ = List_exportToChar(aV%rList)
  else
     call die(myname_)
  endif

 end function exportRListToChar_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportIAttr_ - return AttrVect INTEGER attribute as a vector
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the integer attribute corresponding to the tag defined in the input 
! {\tt CHARACTER} argument {\tt AttrTag}, and returns it in the 
! {\tt INTEGER} output array {\tt outVect}, and its length in the output
! {\tt INTEGER} argument {\tt lsize}.
!
! {\bf N.B.:}  This routine will fail if the {\tt AttrTag} is not in 
! the {\tt AttrVect} {\tt List} component {\tt aV\%iList}.
!
! {\bf N.B.:}  The flexibility of this routine regarding the pointer 
! association status of the output argument {\tt outVect} means the
! user must invoke this routine with care.  If the user wishes this
! routine to fill a pre-allocated array, then obviously this array
! must be allocated prior to calling this routine.  If the user wishes
! that the routine {\em create} the output argument array {\tt outVect},
! then the user must ensure this pointer is not allocated (i.e. the user
! must nullify this pointer) before this routine is invoked.
!
! {\bf N.B.:}  If the user has relied on this routine to allocate memory
! associated with the pointer {\tt outVect}, then the user is responsible 
! for deallocating this array once it is no longer needed.  Failure to 
! do so will result in a memory leak.
!
! !INTERFACE:

 subroutine exportIAttr_(aV, AttrTag, outVect, lsize)

!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),         intent(in)  :: aV
      character(len=*),       intent(in)  :: AttrTag

! !OUTPUT PARAMETERS: 

      integer,  dimension(:), pointer     :: outVect
      integer,                intent(out) :: lsize

! !REVISION HISTORY:
! 	19Oct01 - J.W. Larson <larson@mcs.anl.gov> - initial (slow) 
!                 prototype.
! 	 6May02 - J.W. Larson <larson@mcs.anl.gov> - added capability 
!                 to work with pre-allocated outVect.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportIAttr_'

  integer :: index, ierr, n

       ! Index the attribute we wish to extract:

  index = indexIA_(aV, attrTag)

       ! Determine the number of data points:

  lsize = lsize_(aV)

       ! Allocate space for outVect (if it is not already dimensioned)

  if(associated(outVect)) then ! check the size of outVect
     if(size(outVect) < lsize) then
	write(stderr,'(2a,i8,a,i8)') myname_, &
	    ':: ERROR length of output array outVect ', &
	    ' less than length of aV.  size(outVect)=',size(outVect), &
	    ', length of aV=',lsize
	call die(myname_)
     endif
  else ! allocate space for outVect
     allocate(outVect(lsize), stat=ierr)
     if(ierr /= 0) call die(myname_, 'allocate(outVect) failed.', ierr)
  endif

       ! Copy the attribute data into outVect

  do n=1,lsize
     outVect(n) = aV%iAttr(index,n)
  end do

 end subroutine exportIAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: exportRAttr_ - return AttrVect REAL attribute as a vector
!
! !DESCRIPTION:
! This routine extracts from the input {\tt AttrVect} argument {\tt aV} 
! the attribute corresponding to the tag defined in the input 
! {\tt CHARACTER} argument {\tt AttrTag}, and returns it in the 
! {\tt REAL} output array {\tt outVect}, and its length in the output
! {\tt INTEGER} argument {\tt lsize}.
!
! {\bf N.B.:}  This routine will fail if the {\tt AttrTag} is not in 
! the {\tt AttrVect} {\tt List} component {\tt aV\%rList}.
!
! {\bf N.B.:}  The flexibility of this routine regarding the pointer 
! association status of the output argument {\tt outVect} means the
! user must invoke this routine with care.  If the user wishes this
! routine to fill a pre-allocated array, then obviously this array
! must be allocated prior to calling this routine.  If the user wishes
! that the routine {\em create} the output argument array {\tt outVect},
! then the user must ensure this pointer is not allocated (i.e. the user
! must nullify this pointer) before this routine is invoked.
!
! {\bf N.B.:}  If the user has relied on this routine to allocate memory
! associated with the pointer {\tt outVect}, then the user is responsible 
! for deallocating this array once it is no longer needed.  Failure to 
! do so will result in a memory leak.
!
! !INTERFACE:

 subroutine exportRAttr_(aV, AttrTag, outVect, lsize)
!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),     intent(in)  :: aV
      character(len=*),   intent(in)  :: AttrTag

! !OUTPUT PARAMETERS: 

      real, dimension(:), pointer     :: outVect
      integer,            intent(out) :: lsize


! !REVISION HISTORY:
! 	19Oct01 - J.W. Larson <larson@mcs.anl.gov> - initial (slow) 
!                 prototype.
! 	 6May02 - J.W. Larson <larson@mcs.anl.gov> - added capability 
!                 to work with pre-allocated outVect.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::exportRAttr_'

  integer :: index, ierr, n

       ! Index the attribute we wish to extract:

  index = indexRA_(aV, attrTag)

       ! Determine the number of data points:

  lsize = lsize_(aV)

  if(associated(outVect)) then
     if(size(outVect) < lsize) then ! check the size of outVect
	write(stderr,'(2a,i8,a,i8)') myname_, &
	    ':: ERROR length of output array outVect ', &
	    ' less than length of aV.  size(outVect)=',size(outVect), &
	    ', length of aV=',lsize
	call die(myname_)
     endif
  else ! allocate space for outVect
     allocate(outVect(lsize), stat=ierr)
     if(ierr /= 0) call die(myname_, 'allocate(outVect) failed.', ierr)
  endif

       ! Copy the attribute data into outVect

  do n=1,lsize
     outVect(n) = aV%rAttr(index,n)
  end do

 end subroutine exportRAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: importIAttr_ - import INTEGER vector to AttrVect 
!
! !DESCRIPTION:
! This routine imports into the input/output {\tt AttrVect} argument 
! {\tt aV} the integer attribute corresponding to the tag defined in the 
! input {\tt CHARACTER} argument {\tt AttrTag}.  The data to be imported
! is provided in the {\tt INTEGER} input array {\tt inVect}, and the 
! number of entries to be imported in the optional input {\tt INTEGER} 
! argument {\tt lsize}.
!
! {\bf N.B.:}  This routine will fail if the {\tt AttrTag} is not in 
! the {\tt AttrVect} {\tt List} component {\tt aV\%iList}.
!
! !INTERFACE:

 subroutine importIAttr_(aV, AttrTag, inVect, lsize)
!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr

      implicit none

! !INPUT PARAMETERS: 

      character(len=*),       intent(in)    :: AttrTag
      integer,  dimension(:), pointer       :: inVect
      integer, optional,      intent(in)    :: lsize

! !INPUT/OUTPUT PARAMETERS: 

      type(AttrVect),         intent(inout) :: aV

! !REVISION HISTORY:
! 	19Oct01 - J.W. Larson <larson@mcs.anl.gov> - initial (slow) 
!                 prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::importIAttr_'

  integer :: index, aVsize, ierr, n, mysize

       ! Index the attribute we wish to extract:

  index = indexIA_(aV, attrTag)

       ! Determine the number of data points:

  aVsize = lsize_(aV)

       ! Check input array size vs. lsize_(aV):

  if(present(lsize)) then
     if(aVsize < lsize) then
	write(stderr,'(3a,i8,a,i8)') myname_, &
	               ':: ERROR--attempt to import too many entries ', &
                       'into AttrVect aV.  AttrVect_lsize(aV)=',aVsize, &
                       ', number of entries to be imported=',lsize
	call die(myname_)
     endif
     mysize=lsize
  else
     if(aVsize < size(inVect)) then
	write(stderr,'(3a,i8,a,i8)') myname_, &
	               ':: ERROR--attempt to import too many entries ', &
                       'into AttrVect aV.  AttrVect_lsize(aV)=',aVsize, &
                       ' , number of entries to be imported=',size(inVect)
	call die(myname_)
     endif
     mysize = aVsize
  endif

       ! Copy the data from inVect to its attribute slot:

  do n=1,mysize
     aV%iAttr(index,n) = inVect(n)
  end do

 end subroutine importIAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: importRAttr_ - import REAL vector to AttrVect 
!
! !DESCRIPTION:
! This routine imports into the input/output {\tt AttrVect} argument 
! {\tt aV} the real attribute corresponding to the tag defined in the 
! input {\tt CHARACTER} argument {\tt AttrTag}.  The data to be imported
! is provided in the {\tt REAL} input array {\tt inVect}, and its 
! length in the optional input {\tt INTEGER} argument {\tt lsize}.
!
! {\bf N.B.:}  This routine will fail if the {\tt AttrTag} is not in 
! the {\tt AttrVect} {\tt List} component {\tt aV\%rList}.
!
! !INTERFACE:

 subroutine importRAttr_(aV, AttrTag, inVect, lsize)
!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr

      implicit none

! !INPUT PARAMETERS: 

      character(len=*),   intent(in)    :: AttrTag
      real, dimension(:), pointer       :: inVect
      integer, optional,  intent(in)    :: lsize

! !INPUT/OUTPUT PARAMETERS: 

      type(AttrVect),     intent(inout) :: aV



! !REVISION HISTORY:
! 	19Oct01 - J.W. Larson <larson@mcs.anl.gov> - initial (slow) 
!                 prototype.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::importRAttr_'

  integer :: index, aVsize, ierr, n, mysize

       ! Index the attribute we wish to extract:

  index = indexRA_(aV, attrTag)

       ! Determine the number of data points:

  aVsize = lsize_(aV)

       ! Check input array size vs. lsize_(aV):

  if(present(lsize)) then
     if(aVsize < lsize) then
	write(stderr,'(3a,i8,a,i8)') myname_, &
	               ':: ERROR--attempt to import too many entries ', &
                       'into AttrVect aV.  AttrVect_lsize(aV)=',aVsize, &
                       ', number of entries to be imported=',lsize
	call die(myname_)
     endif
     mysize=lsize
  else
     if(aVsize < size(inVect)) then
	write(stderr,'(3a,i8,a,i8)') myname_, &
	               ':: ERROR--attempt to import too many entries ', &
                       'into AttrVect aV.  AttrVect_lsize(aV)=',aVsize, &
                       ' , number of entries to be imported=',size(inVect)
	call die(myname_)
     endif
     mysize=aVsize
  endif

       ! Copy the attribute data into outVect

  do n=1,mysize
     aV%rAttr(index,n) = inVect(n)
  end do

 end subroutine importRAttr_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: Copy_ - copy specific data from one Av to another
!
! !DESCRIPTION:
! This routine copies from input argment {\tt aVin} into the output 
! {\tt AttrVect} argument {\tt aVout} the real and integer attributes specified in 
! input {\tt CHARACTER} argument {\tt iList} and {\tt rList}. The attributes can
! be listed in any order.  If neither {\tt iList} nor {\tt rList} are provided, 
! all attributes shared between {\tt aVin} and {\tt aVout} will be copied.
!
! If any attributes in {\tt aVout} have different names but represent the
! the same quantity and should still be copied, you must provide a translation
! argument {\tt TrList} and/or {\tt TiList}.  The translation arguments should
! be identical to the {\tt rList} or {\tt iList} but with the correct {\tt aVout}
! name subsititued at the appropriate place.
!
! {\bf N.B.:}  This routine will fail if the {\tt aVout} is not initialized or
! if any of the specified attributes are not present in either {\tt aVout} or {\tt aVin}.
!
! !INTERFACE:

 subroutine Copy_(aVin, rList, TrList, iList, TiList, aVout)

!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr
      use m_List ,         only : List
      use m_String ,       only : String_toChar => toChar
      use m_String , 	   only : String
      use m_String , 	   only : String_init
      use m_List,          only : List_get => get
      use m_List,          only : List_nullify => nullify
      use m_List,          only : init,nitem

      implicit none

! !INPUT PARAMETERS: 

      type(AttrVect),     intent(in)       :: aVin
      character(len=*),optional,intent(in) :: iList
      character(len=*),optional,intent(in) :: rList
      character(len=*),optional,intent(in) :: TiList
      character(len=*),optional,intent(in) :: TrList

! !OUTPUT PARAMETERS: 

      type(AttrVect),     intent(out) :: aVout


! !REVISION HISTORY:
! 	12Jun02 - R.L. Jacob <jacob@mcs.anl.gov> - initial version.
! 	13Jun02 - R.L. Jacob <jacob@mcs.anl.gov> - copy shared attributes
!                 if no attribute lists are specified.
!
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::Copy_'

  type(List)   :: rcpList	!  The list of real attributes to copy
  type(List)   :: icpList	!  The list of integer attributes to copy
  type(List)   :: TrcpList	!  Names of output attributes corresponding to input
  type(List)   :: TicpList	!  Names of output attributes corresponding to input
  type(String) :: attr          !  an individual attribute
  type(String) :: attr2         !  an individual attribute
  integer      :: i,j,ier,ierr
  integer      :: inx,outx
  integer      :: num_indices   ! Overlapping attribute index number

  ! Overlapping attribute index storage arrays:
  integer, dimension(:), pointer :: aVinindices, aVoutindices

  character*7 :: data_flag	! character variable used as data type flag

  call List_nullify(rcpList)
  call List_nullify(icpList)
  call List_nullify(TrcpList)
  call List_nullify(TicpList)

  if(lsize_(aVin) .ne. lsize_(aVout)) then
     write(stderr,'(2a)')myname_, &
      'MCTERROR:  Input aV and output aV do not have the same size'
     call die(myname_,'lsize check',ier)
  endif

!  Copy the listed real attributes
  if( present(rList) .and. (len_trim(rList)>0) ) then

    call init(rcpList,rList)	! init.List()

! check translation list
    if( present(TrList) .and. (len_trim(TrList)>0) ) then
      call init(TrcpList,TrList)
      if( nitem(rcpList) .ne. nitem(TrcpList)) then
        write(stderr,'(2a)')myname_, &
         'MCTERROR:  Input rList and TrList do not have the same size'
        call die(myname_,'nitem TrList check',ier)
      endif
    endif


    if(nitem(rcpList) .ge. 1) then
     do i=1,lsize_(aVin)
      do j=1,nitem(rcpList)
       call List_get(attr,j,rcpList)
       if(present(TrList)) then
         call List_get(attr2,j,TrcpList)
       else
	 call String_init(attr2,attr)
       endif
       inx=indexRA_(aVin,String_toChar(attr),dieWith=myname_//'real aVin')
       outx=indexRA_(aVout,String_toChar(attr2),dieWith=myname_//'real aVout')
       aVout%rAttr(outx,i)=aVin%rAttr(inx,i)
      enddo
     enddo
    endif

  endif

!  Copy the listed integer attributes
  if( present(iList) .and. (len_trim(iList)>0) ) then

    call init(icpList,iList)	! init.List()
    
! check translation list
    if( present(TiList) .and. (len_trim(TiList)>0) ) then
      call init(TicpList,TiList)
      if( nitem(icpList) .ne. nitem(TicpList)) then
        write(stderr,'(2a)')myname_, &
         'MCTERROR:  Input iList and TiList do not have the same size'
        call die(myname_,'nitem TiList check',ier)
      endif
    endif

    if(nitem(icpList) .ge. 1) then
     do i=1,lsize_(aVin)
      do j=1,nitem(icpList)
       call List_get(attr,j,icpList)
       if(present(TiList)) then
         call List_get(attr2,j,TicpList)
       else
	 call String_init(attr2,attr)
       endif
       inx=indexIA_(aVin,String_toChar(attr),dieWith=myname_//'int aVin')
       outx=indexIA_(aVout,String_toChar(attr2),dieWith=myname_//'int aVout')
       aVout%iAttr(outx,i)=aVin%iAttr(inx,i)
      enddo
     enddo
    endif
  endif

! if neither rList nor iList is present, copy shared attibutes
! from in to out.

  if( .not.present(rList) .and. .not.present(iList)) then

    data_flag = 'REAL'
    call aVaVSharedAttrIndexList_(aVin, aVout, data_flag, num_indices, &
				aVinindices, aVoutindices)
    if(num_indices .gt. 0) then
     do i=1,lsize_(aVin)
       do j=1,num_indices
	 aVout%rAttr(aVoutindices(j),i)=aVin%rAttr(aVinindices(j),i)
       enddo
     enddo
    endif
    deallocate(aVinindices, aVoutindices,stat=ierr)
    if(ierr /= 0) call die(myname_,'deallocate real(Vinindices...',ierr)

    data_flag = 'INTEGER'
    call aVaVSharedAttrIndexList_(aVin, aVout, data_flag, num_indices, &
				aVinindices, aVoutindices)
    if(num_indices .gt. 0) then
     do i=1,lsize_(aVin)
       do j=1,num_indices
	 aVout%iAttr(aVoutindices(j),i)=aVin%iAttr(aVinindices(j),i)
       enddo
     enddo
    endif
    deallocate(aVinindices, aVoutindices,stat=ierr)
    if(ierr /= 0) call die(myname_,'deallocate int(Vinindices...',ierr)

  endif

 end subroutine Copy_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: Sort_ - return index permutation keyed by a list of
!            attributes
!
! !DESCRIPTION:
! The subroutine {\tt Sort\_()} uses a list of keys defined by the {\tt List} 
! {\tt sList}, searches for the appropriate integer or real attributes
! referenced by the items in {\tt sList} ( that is, it identifies the 
! appropriate entries in {aV\%iList} and {\tt aV\%rList}), and then 
! uses these keys to generate a permutation {\tt perm} that will put
! the entries of the attribute vector {\tt aV} in lexicographic order
! as defined by {\tt sList} (the ordering in {\tt sList} being from
! left to right.
!
! {\bf N.B.:}  This routine will fail if {\tt aV\%rList} and 
! {\tt aV\%rList} share one or more common entries. 
!
! {\bf N.B.:}  This routine will fail if {\tt aV\%rList} and 
!
! !INTERFACE:

 subroutine Sort_(aV, sList, perm, descend, perrWith, dieWith)
!
! !USES:
!
      use m_String,        only : String
      use m_String,        only : String_tochar => tochar
      use m_List ,         only : List_index => index
      use m_List ,         only : List_nitem => nitem
      use m_List ,         only : List_get   => get
      use m_die ,          only : die
      use m_stdio ,        only : stderr
      use m_SortingTools , only : IndexSet
      use m_SortingTools , only : IndexSort

      implicit none

      type(AttrVect), intent(in)                  :: aV
      type(List),     intent(in)                  :: sList
      integer, dimension(:), pointer              :: perm
      logical, dimension(:), optional, intent(in) :: descend
      character(len=*), optional, intent(in)      :: perrWith
      character(len=*), optional, intent(in)      :: dieWith


! !REVISION HISTORY:
! 	20Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype
!       25Apr01 - R.L. Jacob <jacob@mcs.anl.gov> - add -1 to make a
!                 backwards loop go backwards
!       14Jun01 - J. Larson / E. Ong -- Fixed logic bug in REAL attribute
!                 sort (discovered by E. Ong), and cleaned up error / 
!                 shutdown logic.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::Sort_'

! local variables

        ! storage for key extracted from sList:

  type(String) :: key

        ! number of keys, loop index, error flag, and length:

  integer :: nkeys, n, ierr, length

        ! key indices for av%rAttr and av%iAttr, respectively:

  integer, dimension(:), allocatable :: rIndex, iIndex 

        ! count the sorting keys:

  nkeys = List_nitem(sList)

        ! allocate and initialize rIndex and iIndex to
        ! zero (the null return values from the functions
        ! indexRA_() and indexIA_() ).

  allocate(rIndex(nkeys), iIndex(nkeys), stat=ierr)
     
  rIndex = 0
  iIndex = 0

        ! Loop over the keys in the list, and identify the
        ! appropriate integer or real attribute, storing the
        ! attribute index in iIndex(:) or rIndex(:), respectively.

  do n = 1, nkeys

        ! grab the next key

     call List_get(key, n, sList)

        ! determine wheter this key refers to an
        ! integer or real attribute:

     rIndex(n) = indexRA_(aV, String_tochar(key))
     iIndex(n) = indexIA_(aV, String_tochar(key))

        ! If both rIndex(n) and iIndex(n) are greater than
        ! zero, then we have an integer attribute sharing 
        ! the same name as a real attribute, and there is 
        ! no clear path as to which one is the sort key.
        ! This is a fatal error that triggers shutdown.

     if ((rIndex(n) > 0) .and. (iIndex(n) > 0)) then
	if(.not.present(dieWith)) then
	   if(present(perrWith)) write(stderr,'(4a)') myname, &
		":: ambiguous key, ", perrWith, &
		" both iIndex(n) and rIndex(n) positive."
	    call die(myname_,":: both iIndex(n) and rIndex(n) > 0.")
	else
	   if(present(perrWith)) then
	       write(stderr,'(4a)') myname_,":: ", perrWith, &
		       " both iIndex(n) and rIndex(n) positive."
           endif
	   call die(myname_,dieWith)
	endif
     endif

        ! If both rIndex(n) and iIndex(n) are nonpositive,
        ! then the requested sort key is not present in either
        ! aV%rList or aV%iList, and we cannot perform the sort.
        ! This is a fatal error that triggers shutdown.

     if ((rIndex(n) <= 0) .and. (iIndex(n) <= 0)) then
	if(.not.present(dieWith)) then
	   if(present(perrWith)) write(stderr,'(4a)') myname,":: ", &
		perrWith, &
		" both iIndex(n) and rIndex(n) nonpositive"
	   call die(myname_,":: both iIndex(n) and rIndex(n) <= 0.")
	else
	   if(present(perrWith)) then
	      write(stderr,'(4a)') myname_,":: ", perrWith,	&
		   " both iIndex(n) and rIndex(n) nonpositive"
           endif
	   call die(myname_,dieWith)
	endif
     endif

        ! If only one of rIndex(n) or iIndex(n) is positive,
        ! set the other value to zero.

     if (iIndex(n) > 0) rIndex(n) = 0
     if (rIndex(n) > 0) iIndex(n) = 0

  enddo ! do n=1,nkeys

        ! Now we have the locations of the keys in the integer and
        ! real attribute storage areas aV%iAttr and aV%rAttr, respectively.
        ! our next step is to construct and initialize the permutation
        ! array perm.  First step--determine the length of aV using 
        ! lsize_():

  length = lsize_(aV)

  allocate(perm(length), stat=ierr)

        ! Initialize perm(i)=i, for i=1,length

  call IndexSet(perm)

        ! Now we can perform the stable successive keyed sorts to
        ! transform perm into the permutation that will place the
        ! entries of the attribute arrays in the lexicographic order
        ! defined by sList.  This is achieved by successive calls to
        ! IndexSort(), but in reverse order to the order of the keys
        ! as they appear in sList.

  do n=nkeys, 1, -1
     if(iIndex(n) > 0) then
	if(present(descend)) then
	   call IndexSort(length, perm, aV%iAttr(iIndex(n),:), &
		          descend(n))
	else
   	   call IndexSort(length, perm, aV%iAttr(iIndex(n),:), &
               		  descend=.false.)
	endif ! if(present(descend)...
     else
	if(rIndex(n) > 0) then
	   if(present(descend)) then
	      call IndexSort(length, perm, aV%rAttr(rIndex(n),:), &
		             descend(n))
	   else
	      call IndexSort(length, perm, aV%rAttr(rIndex(n),:), &
               		     descend=.false.)
	   endif ! if(present(descend)...
	endif ! if (rIndex(n) > 0)...
     endif ! if (iIndex(n) > 0)...
  enddo

        ! Now perm(1:length) is the transformation we seek--we are
        ! finished.

  deallocate(iIndex, rIndex, stat=ierr)  ! clean up allocated arrays.

 end subroutine Sort_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: Permute_ - return index permutation keyed by a list of
!            attributes
!
! !DESCRIPTION:
! The subroutine {\tt Permute\_()} uses a a permutation {\tt perm} (which can
! be generated by the routine {\tt Sort\_()} in this module) to rearrange
! the entries in the attribute integer and real storage areas of the
! input attribute vector {\tt aV}--{\tt aV\%iAttr} and {\tt aV\%rAttr}, 
! respectively.
!
! !INTERFACE:

 subroutine Permute_(aV, perm, perrWith, dieWith)
!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr
      use m_SortingTools , only : Permute

      implicit none

      type(AttrVect), intent(inout) :: aV
      integer, dimension(:), intent(in) :: perm
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith

! !REVISION HISTORY:
! 	23Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::Permute_'

! local variables

  integer, dimension(:,:), allocatable :: iAtmp
  real,    dimension(:,:), allocatable :: rAtmp
  integer :: i

        ! Check input arguments for compatibility--assure
        ! lsize_(aV) = size(perm); that is, make sure the
        ! index permutation is the same length as the vectors
        ! it will re-arrange.

  if (size(perm) /= lsize_(aV)) then
     if(.not.present(dieWith)) then
	if(present(perrWith)) write(stderr,'(4a,i8,a,i8)') myname, &
	  ":: size mismatch, ", perrWith, &
	  "size(perm)=",size(perm)," lsize_(aV)=",lsize_(aV)
     else
	write(stderr,'(4a,i8,a,i8)') myname, &
	 ":: size mismatch, ", dieWith,	&
	 "size(perm)=",size(perm)," lsize_(aV)=",lsize_(aV)
	call die(dieWith)
     endif
  endif

  if(size(perm) == lsize_(aV)) then

        ! Permute integer attributes:
     if(nIAttr_(aV) /= 0) then
	do i=1,nIAttr_(aV)
	   call Permute(aV%iAttr(i,:),perm,lsize_(aV))
	end do
     endif

        ! Permute real attributes:
     if(nRAttr_(aV) /= 0) then
	do i=1,nRAttr_(aV)
	   call Permute(aV%rAttr(i,:),perm,lsize_(aV))
	end do
     endif

  endif

 end subroutine Permute_

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: SortPermute_ - Place AttrVect data in lexicographic order.
!
! !DESCRIPTION:
!
! The subroutine {\tt SortPermute\_()} uses the routine {\tt Sort\_()} 
! to create an index permutation {\tt perm} that will place the AttrVect
! entries in the lexicographic order defined by the keys in the List 
! variable {\tt key\_list}.  This permutation is then used by the routine
! {\tt Permute\_()} to place the AttreVect entries in lexicographic order.
!
! !INTERFACE:

 subroutine SortPermute_(aV, key_list, descend, perrWith, dieWith)
!
! !USES:
!
      use m_die ,          only : die
      use m_stdio ,        only : stderr

      implicit none

      type(AttrVect), intent(inout) :: aV
      type(List), intent(in)        :: key_list
      logical , dimension(:), optional, intent(in) :: descend
      character(len=*), optional, intent(in) :: perrWith
      character(len=*), optional, intent(in) :: dieWith


! !REVISION HISTORY:
! 	24Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::Permute_'

! local variables

       ! Permutation array pointer perm(:)
  integer, dimension(:), pointer :: perm
       ! Error flag ierr
  integer :: ierr

       ! Step One: Generate the index permutation perm(:)

  if(present(descend)) then
     call Sort_(aV, key_list, perm, descend, perrWith, dieWith)
  else
     call Sort_(aV, key_list, perm, perrWith=perrWith, &
	        dieWith=dieWith)
  endif

       ! Step Two:  Apply the index permutation perm(:)

  call Permute_(aV, perm, perrWith, dieWith)

       ! Step Three:  deallocate temporary array used to 
       ! store the index permutation (this was allocated 
       ! in the routine Sort_()

  deallocate(perm, stat=ierr)

  end subroutine SortPermute_

! Sorting:
!
!	aV%iVect(:,:) =		&
!		aV%iVect((/(indx(i),i=1,lsize(aV))/),:)
!
!	aV%iVect((/(indx(i),i=1,lsize(aV))/),:) =	&
!		aV%iVect(:,:)
!
!	aV%iVect(:,ikx),aV%iVect(:,iks)
!
!

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !IROUTINE: aVaVSharedAttrIndexList_ - AttrVect shared attributes.
!
! !DESCRIPTION:  {\tt aVaVSharedAttrIndexList\_()} takes a pair of 
! user-supplied {\tt AttrVect} variables {\tt aV1} and {\tt aV2}, 
! and for choice of either {\tt REAL} or {\tt INTEGER} attributes (as
! specified literally in the input {\tt CHARACTER} argument {\tt attrib})
! returns the number of shared attributes {\tt NumShared}, and arrays of
! indices {\tt Indices1} and {\tt Indices2} to their storage locations
! in {\tt aV1} and {\tt aV2}, respectively.
!
! {\bf N.B.:}  This routine returns two allocated arrays---{\tt Indices1(:)} 
! and {\tt Indices2(:)}---which must be deallocated once the user no longer
! needs them.  Failure to do this will create a memory leak.
!
! !INTERFACE:

 subroutine aVaVSharedAttrIndexList_(aV1, aV2, attrib, NumShared, &
                                     Indices1, Indices2)

!
! !USES:
!
      use m_stdio
      use m_die,      only : MP_perr_die, die, warn

      use m_List,     only : GetSharedListIndices

      implicit none

! !INPUT PARAMETERS: 
!
      type(AttrVect),    intent(in)  :: aV1   
      type(AttrVect),    intent(in)  :: aV2
      character*7,       intent(in)  :: attrib

! !OUTPUT PARAMETERS:   
!
      integer,           intent(out) :: NumShared

      integer,dimension(:), pointer  :: Indices1
      integer,dimension(:), pointer  :: Indices2

! !REVISION HISTORY:
!       07Feb01 - J.W. Larson <larson@mcs.anl.gov> - initial version
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname_=myname//'::aVaVSharedAttrIndexList_'

  integer :: ierr

       ! Based on the value of the argument attrib, pass the 
       ! appropriate pair of Lists for comparison...

  select case(trim(attrib))
  case('REAL','real')
     call GetSharedListIndices(aV1%rList, aV2%rList, NumShared, &
                                 Indices1, Indices2)
  case('INTEGER','integer')
     call GetSharedListIndices(aV1%iList, aV2%iList, NumShared, &
                                 Indices1, Indices2)
  case default
     write(stderr,'(4a)') myname_,":: value of argument attrib=",attrib, &
          " not recognized.  Allowed values: REAL, real, INTEGER, integer"
     ierr = 1
     call die(myname_, 'invalid value for attrib', ierr)
  end select

 end subroutine aVaVSharedAttrIndexList_

 end module m_AttrVect
!.




