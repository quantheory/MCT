!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !MODULE: m_SparseMatrixDecomp -- Parallel sparse matrix decomposition.
!
! !DESCRIPTION:
! The {\tt SparseMatrix} datatype provides sparse matrix storage for 
! the parallel matrix-vector multiplication ${\bf y} = {\bf M} {\bf x}$.
! This module provides services to create decompositions for the 
! {\tt SparseMatrix}.  The matrix decompositions available are row 
! and column decompositions.  They are generated by invoking the 
! appropriate routine in this module, and passing the corresponding 
! {\em vector} decomposition.  For a row (column) decomposition, one 
! invokes the routine {\tt ByRow()} ({\tt ByColumn()}), passing the 
! domain decomposition for the vector {\bf y} ({\bf x}).
!
! !INTERFACE:

 module m_SparseMatrixDecomp

      private   ! except

! !PUBLIC MEMBER FUNCTIONS:
!
      public :: ByColumn
      public :: ByRow


    interface ByColumn ; module procedure &
         ByColumnGSMap_
    end interface

    interface ByRow ; module procedure &
         ByRowGSMap_
    end interface

! !REVISION HISTORY:
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial prototype
!                 and API specifications.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname='m_SparseMatrixDecomp'

 contains

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ByColumnGSMap_()--Generate Row-based GlobalSegMap for SparseMatrix
! 
! !INTERFACE:

 subroutine ByColumnGSMap_(xGSMap, sMat, sMGSMap, root, comm)
!
! !USES:
!
   use m_die,  only: MP_perr_die
   use m_List, only: List
   use m_List, only: List_init => init
   use m_List, only: List_clean => clean

   use m_GlobalSegMap, only: GlobalSegMap
   use m_GlobalSegMap, only: GlobalSegMap_init => init
   use m_GlobalSegMap, only: GlobalSegMap_peLocs => peLocs
   use m_GlobalSegMap, only: GlobalSegMap_comp_id => comp_id
   use m_GlobalSegMap, only: GlobalSegMap_gsize => gsize
   use m_GlobalSegMap, only: GlobalSegMap_ngseg => ngseg

   use m_SparseMatrix, only: SparseMatrix

   use m_SparseMatrix, only: SparseMatrix_lsize => lsize
   use m_SparseMatrix, only: SparseMatrix_indexIA => indexIA
   use m_SparseMatrix, only: SparseMatrix_SortPermute => SortPermute

   implicit none

! !INPUT PARAMETERS: 
!
   type(GlobalSegMap), intent(in)    :: xGSMap
   integer,            intent(in)    :: root
   integer,            intent(in)    :: comm

! !INPUT/OUTPUT PARAMETERS: 
!
   type(SparseMatrix), intent(inout) :: sMat

! !OUTPUT PARAMETERS:
!
   type(GlobalSegMap), intent(out) :: sMGSMap

! !DESCRIPTION: This routine is invoked from all processes on the 
! communicator {\tt comm} to create from an input {\tt SparseMatrix}
! {\tt sMat} (valid only on the {\tt root} process) and an input 
! {\bf x}-vector decomposition described by the {\tt GlobalSegMap} 
! argument {\tt xGSMap} (valid at least on the {\tt root}) to create 
! an output {\tt GlobalSegMap} decomposition of the matrix elements 
! {\tt sMGSMap}, which is valid on all processes on the communicator.
! This matrix {\tt GlobalSegMap} describes the corresponding column 
! decomposition of {\tt sMat}.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by column and row.
!
! !REVISION HISTORY: 
!
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial API spec.
!       26Apr01 - R.L. Jacob <jacob@mcs.anl.gov> - add use statements for
!                 GlobalSegMap_init and GSMap_peLocs.
!                 Add gsize argument required to GSMap_peLocs.
!                 Add underscore to ComputeSegments call so it matches
!                 the subroutine decleration.
!                 change attribute on starts,lengths, and pe_locs to
!                 pointer to match GSMap_init.
!                 add use m_die statement
!       26Apr01 - J.W. Larson <larson@mcs.anl.gov> - fixed major logic bug
!                 that had all processes executing some operations that 
!                 should only occur on the root.
!EOP
!-------------------------------------------------------------------------

  character(len=*),parameter :: myname_=myname//'ByColumnGSMap_'
! Process ID number
  integer :: myID
! Attributes for the output GlobalSegMap
  integer :: gsize, comp_id, ngseg
! Temporary array for identifying each matrix element column and 
! process ID destination
  integer, dimension(:), allocatable :: gCol, element_pe_locs 
! Index to identify the gcol attribute in sMat:
  integer :: igCol
! Temporary arrays for matrix GlobalSegMap attributes
  integer, dimension(:), pointer :: starts, lengths, pe_locs
! List storage for sorting keys
  type(List) :: sort_keys
! Error flag
  integer :: ierr
! Loop index
  integer :: i

       ! Determine process id number myID

  call MPI_COMM_RANK(comm, myID, ierr)
  if(ierr /= 0) then
     call MP_perr_die(myname_,'call MPI_COMM_RANK(...',ierr)
  endif

       ! First step:  a lot of prep work on the root only:

  if(myID == root) then

       ! The global size of matrix GlobalSegMap is the number nonzero
       ! elements in sMat.  

     gsize = SparseMatrix_lsize(sMat)

       ! The matrix GlobalSegMap inherits the component ID from xGSMap:

     comp_id = GlobalSegMap_comp_id(xGSMap)
   
       ! Sort the matrix entries in sMat by column, then row.  First,
       ! create the key list...

     call List_init(sort_keys,'gcol:grow')

       ! Now perform the sort/permute...

     call SparseMatrix_SortPermute(sMat, sort_keys)

       ! Allocate storage space for matrix element column indices and
       ! process ID destinations

     allocate(gCol(gsize), element_pe_locs(gsize), stat=ierr)

     if(ierr /= 0) then
	call MP_perr_die(myname_,'allocate(gCol...',ierr)
     endif

       ! Extract global column information and place in array gCol

     igCol = SparseMatrix_indexIA(sMat,'gcol')

     do i=1, gsize
	gCol(i) = sMat%data%iAttr(igCol,i)
     end do

       ! Compute process ID destination for each matrix element,
       ! and store in the array element_pe_locs

     call GlobalSegMap_peLocs(xGSMap, gsize, gCol, element_pe_locs)

       ! Using the entries of gCol and element_pe_locs, build the
       ! output GlobalSegMap attribute arrays starts(:), lengths(:),
       ! and pe_locs(:)

     call ComputeSegments_(element_pe_locs, gCol, gsize, ngseg, starts, &
                           lengths, pe_locs)

  endif ! if(myID == root)

       ! Using this local data on the root, create the SparseMatrix 
       ! GlobalSegMap sMGSMap (which will be valid on all processes
       ! on the communicator:

  call GlobalSegMap_init(sMGSMap, ngseg, starts, lengths, pe_locs, &
                         root, comm, comp_id, gsize)

       ! Clean up (on the root)

  if(myID == root) then
     deallocate(starts, lengths, pe_locs, stat=ierr)
     if(ierr /= 0) then
	call MP_perr_die(myname_,'deallocate(starts...',ierr)
     endif
  endif

 end subroutine ByColumnGSMap_

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ByRowGSMap_()--Generate Row-based GlobalSegMap for SparseMatrix
! 
! !INTERFACE:

 subroutine ByRowGSMap_(yGSMap, sMat, sMGSMap, root, comm)
!
! !USES:
!

   use m_die,  only: MP_perr_die

   use m_List, only: List
   use m_List, only: List_init => init
   use m_List, only: List_clean => clean

   use m_GlobalSegMap, only: GlobalSegMap
   use m_GlobalSegMap, only: GlobalSegMap_init => init
   use m_GlobalSegMap, only: GlobalSegMap_peLocs => peLocs
   use m_GlobalSegMap, only: GlobalSegMap_comp_id => comp_id
   use m_GlobalSegMap, only: GlobalSegMap_gsize => gsize
   use m_GlobalSegMap, only: GlobalSegMap_ngseg => ngseg

   use m_SparseMatrix, only: SparseMatrix

   use m_SparseMatrix, only: SparseMatrix_lsize => lsize
   use m_SparseMatrix, only: SparseMatrix_indexIA => indexIA
   use m_SparseMatrix, only: SparseMatrix_SortPermute => SortPermute

   implicit none

! !INPUT PARAMETERS: 
!
   type(GlobalSegMap), intent(in)    :: yGSMap
   integer,            intent(in)    :: root
   integer,            intent(in)    :: comm

! !INPUT/OUTPUT PARAMETERS: 
!
   type(SparseMatrix), intent(inout) :: sMat

! !OUTPUT PARAMETERS:
!
   type(GlobalSegMap), intent(out) :: sMGSMap

! !DESCRIPTION: This routine is invoked from all processes on the 
! communicator {\tt comm} to create from an input {\tt SparseMatrix}
! {\tt sMat} (valid only on the {\tt root} process) and an input 
! {\bf y}-vector decomposition described by the {\tt GlobalSegMap} 
! argument {\tt yGSMap} (valid at least on the {\tt root}) to create 
! an output {\tt GlobalSegMap} decomposition of the matrix elements 
! {\tt sMGSMap}, which is valid on all processes on the communicator.
! This matrix {\tt GlobalSegMap} describes the corresponding row 
! decomposition of {\tt sMat}.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by row and column.
!
! !REVISION HISTORY: 
!
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial API spec.
!       26Apr01 - R.L. Jacob <jacob@mcs.anl.gov> - add use statements for
!                 GlobalSegMap_init and GSMap_peLocs.
!                 Add gsize argument required to GSMap_peLocs.
!                 Add underscore to ComputeSegments call so it matches
!                 the subroutine decleration.
!                 change attribute on starts,lengths, and pe_locs to
!                  pointer to match GSMap_init.
!       26Apr01 - J.W. Larson <larson@mcs.anl.gov> - fixed major logic bug
!                 that had all processes executing some operations that 
!                 should only occur on the root.
!EOP
!-------------------------------------------------------------------------

  character(len=*),parameter :: myname_=myname//'ByRowGSMap_'
! Process ID number
  integer :: myID
! Attributes for the output GlobalSegMap
  integer :: gsize, comp_id, ngseg
! Temporary array for identifying each matrix element row and 
! process ID destination
  integer, dimension(:), allocatable :: gRow, element_pe_locs 
! Index to identify the grow attribute in sMat:
  integer :: igRow
! Temporary arrays for matrix GlobalSegMap attributes
  integer, dimension(:), pointer :: starts, lengths, pe_locs
! List storage for sorting keys
  type(List) :: sort_keys
! Error flag
  integer :: ierr
! Loop index
  integer :: i

       ! Determine process id number myID

  call MPI_COMM_RANK(comm, myID, ierr)
  if(ierr /= 0) then
     call MP_perr_die(myname_,'call MPI_COMM_RANK(...',ierr)
  endif

       ! First step:  a lot of prep work on the root only:

  if(myID == root) then

       ! The global size of matrix GlobalSegMap is the number of rows.  

     gsize = SparseMatrix_lsize(sMat)

       ! The matrix GlobalSegMap inherits the component ID from yGSMap:

     comp_id = GlobalSegMap_comp_id(yGSMap)
   
       ! Sort the matrix entries in sMat by row, then column.  First,
       ! create the key list...

     call List_init(sort_keys,'grow:gcol')

       ! Now perform the sort/permute...

     call SparseMatrix_SortPermute(sMat, sort_keys)

       ! Allocate storage space for matrix element row indices and
       ! process ID destinations

     allocate(gRow(gsize), element_pe_locs(gsize), stat=ierr)

     if(ierr /= 0) then
	call MP_perr_die(myname_,'allocate(gRow...',ierr)
     endif

       ! Extract global row information and place in array gRow

     igRow = SparseMatrix_indexIA(sMat,'grow')

     do i=1, gsize
	gRow(i) = sMat%data%iAttr(igRow,i)
     end do

       ! Compute process ID destination for each matrix element,
       ! and store in the array element_pe_locs

     call GlobalSegMap_peLocs(yGSMap, gsize, gRow, element_pe_locs)

       ! Using the entries of gRow and element_pe_locs, build the
       ! output GlobalSegMap attribute arrays starts(:), lengths(:),
       ! and pe_locs(:)

     call ComputeSegments_(element_pe_locs, gRow, gsize, ngseg, starts, &
                           lengths, pe_locs)

  endif ! if(myID == root)

       ! Using this local data on the root, create the SparseMatrix 
       ! GlobalSegMap sMGSMap (which will be valid on all processes
       ! on the communicator:

  call GlobalSegMap_init(sMGSMap, ngseg, starts, lengths, pe_locs, &
                         root, comm, comp_id, gsize)

       ! Clean up on the root:

  if(myID == root) then
     deallocate(starts, lengths, pe_locs, stat=ierr)
     if(ierr /= 0) then
	call MP_perr_die(myname_,'deallocate(starts...',ierr)
     endif
  endif

 end subroutine ByRowGSMap_

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ComputeSegments_()--Create segments from list data.
! 
! !INTERFACE:

 subroutine ComputeSegments_(element_pe_locs, elements, num_elements, &
                             nsegs, seg_starts, seg_lengths, seg_pe_locs)
!
! !USES:
!

   use m_die,  only: MP_perr_die

   implicit none

! !INPUT PARAMETERS: 
!
   integer, dimension(:), intent(in)  :: element_pe_locs
   integer, dimension(:), intent(in)  :: elements
   integer,               intent(in)  :: num_elements

! !OUTPUT PARAMETERS:
!
   integer,               intent(out) :: nsegs
   integer, dimension(:), pointer     :: seg_starts
   integer, dimension(:), pointer     :: seg_lengths
   integer, dimension(:), pointer     :: seg_pe_locs

! !DESCRIPTION: This routine examins an input list of {\tt num\_elements} 
! process ID locations stored in the array {\tt element\_pe\_locs}, counts
! the number of contiguous segments {\tt nsegs}, and returns the segment 
! start index, length, and process ID location in the arrays {\tt seg\_starts(:)},
! {\tt seg\_lengths(:)}, and {\tt seg\_pe\_locs(:)}, respectively.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by row and column.
!
! !REVISION HISTORY: 
!
!       18Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial version.

!EOP
!-------------------------------------------------------------------------
  character(len=*),parameter :: myname_=myname//'ComputeSegments_'

  integer :: i, ierr, iseg

       ! Input argument sanity checks:

  if(size(elements) < num_elements) then
     call MP_perr_die(myname_,'input argument array element_pe_locs too small', &
	  num_elements-size(element_pe_locs))
  endif

  if(size(elements) < num_elements) then
     call MP_perr_die(myname_,'input argument array elements too small', &
	  num_elements-size(elements))
  endif

       ! First pass:  how many segments?

  do i=1,num_elements

     if(i == 1) then ! bootstrap segment count

	nsegs = 1

     else ! usual point/segment processing

       ! New segment?  If so, increment nsegs.

	if((elements(i) > elements(i-1) + 1) .or. &
	     (element_pe_locs(i) /= element_pe_locs(i-1))) then ! new segment
	   nsegs = nsegs + 1
	endif

     endif ! if(i == 1) block

  end do  ! do i=1,num_elements

  allocate(seg_starts(nsegs), seg_lengths(nsegs), seg_pe_locs(nsegs), &
           stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'allocate(seg_starts...',ierr)
  endif

       ! Second pass:  fill in segment data.

  do i=1,num_elements

     if(i == 1) then  ! bootstrap first segment info.

	iseg = 1
	seg_starts(iseg) = 1
	seg_lengths(iseg) = 1
	seg_pe_locs(iseg) = element_pe_locs(iseg)

     else ! do usual point/segment processing

       ! New segment?  This happens if 1) elements(i) > elements(i-1) + 1, or
       ! 2) element_pe_locs(i) /= element_pe_locs(i-1).

	if((elements(i) > elements(i-1) + 1) .or. &
	     (element_pe_locs(i) /= element_pe_locs(i-1))) then ! new segment

       ! Initialize new segment

	   iseg = iseg + 1
	   seg_starts(iseg) = i
	   seg_lengths(iseg) = 1
	   seg_pe_locs(iseg) = element_pe_locs(i)

	else

       ! Increment current segment length

	   seg_lengths(iseg) = seg_lengths(iseg) + 1

	endif ! If new segment block

     endif ! if(i == 1) block

  end do ! do i=1,num_elements

  if(iseg /= nsegs) then
     call MP_perr_die(myname_,'segment number difference',iseg-nsegs)
  endif

 end subroutine ComputeSegments_

 end module m_SparseMatrixDecomp
